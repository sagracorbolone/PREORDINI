
# AggiornaListino_ordinabile_persistente_SCROLL.py
# Miglioramenti:
# - Area centrale davvero scrollabile (Canvas + Scrollbar) con supporto MouseWheel/Trackpad (Win/Mac/Linux)
# - Ridimensionamento automatico della larghezza del contenuto
# - Stessa logica: categorie in ordine naturale, ordine manuale per pietanza con persistenza in JSON

import psycopg2
import json
import os
from datetime import datetime
import tkinter as tk
from tkinter import messagebox, ttk

db_config = {
    'user': 'sagra',
    'host': 'localhost',
    'database': 'sagra',
    'password': 'plutarco',
    'port': 5432,
}

OUTPUT_DATA_JS = r'C:/sagra/web/preordini/preordini_lib/util/data.js'
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PREFS_PATH = os.path.join(SCRIPT_DIR, 'ordine_pietanze.json')

# ---------- Utilità persistenza ----------
def load_prefs():
    try:
        with open(PREFS_PATH, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {"per_category": {}}
    except Exception as e:
        print("ATTENZIONE: impossibile leggere le preferenze:", e)
        return {"per_category": {}}

def save_prefs(per_cat_widgets):
    prefs = {"per_category": {}}
    for cat_id, rows in per_cat_widgets.items():
        prefs["per_category"][str(cat_id)] = {}
        for r in rows:
            p = r['pietanza']
            include = bool(r['var_chk'].get())
            try:
                ord_val = int(r['var_ord'].get())
            except Exception:
                ord_val = None
            prefs["per_category"][str(cat_id)][str(p['id'])] = {
                "order": ord_val,
                "include": include
            }
    try:
        with open(PREFS_PATH, 'w', encoding='utf-8') as f:
            json.dump(prefs, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print("ATTENZIONE: impossibile salvare le preferenze:", e)

def get_pref_order(prefs, cat_id, item_id):
    try:
        val = prefs["per_category"].get(str(cat_id), {}).get(str(item_id), {})
        return val.get("order", None)
    except Exception:
        return None

def get_pref_include(prefs, cat_id, item_id):
    try:
        val = prefs["per_category"].get(str(cat_id), {}).get(str(item_id), {})
        inc = val.get("include", None)
        if inc is None:
            return True
        return bool(inc)
    except Exception:
        return True

# ---------- Widget scrollabile riutilizzabile ----------
class ScrollableFrame(ttk.Frame):
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.canvas = tk.Canvas(self, highlightthickness=0)
        self.vsb = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.vsb.set)

        self.vsb.pack(side="right", fill="y")
        self.canvas.pack(side="left", fill="both", expand=True)

        self.inner = ttk.Frame(self.canvas)
        self.window_id = self.canvas.create_window((0, 0), window=self.inner, anchor="nw")

        # Aggiorna scrollregion e adatta la larghezza dell'inner alla canvas
        self.inner.bind("<Configure>", self._on_frame_configure)
        self.canvas.bind("<Configure>", self._on_canvas_configure)

        # Bind mouse wheel per scroll (Windows/Mac/Linux)
        self._bind_mousewheel(self.canvas)
        self._bind_mousewheel(self.inner)

    def _on_frame_configure(self, event=None):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _on_canvas_configure(self, event):
        # Mantiene la larghezza del frame uguale a quella della canvas per evitare sovrapposizioni
        self.canvas.itemconfigure(self.window_id, width=event.width)

    def _on_mousewheel(self, event):
        # Windows / MacOS
        if event.delta:
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        # Linux (event.num 4=su, 5=giù)
        elif hasattr(event, 'num'):
            if event.num == 4:
                self.canvas.yview_scroll(-3, "units")
            elif event.num == 5:
                self.canvas.yview_scroll(3, "units")

    def _bind_mousewheel(self, widget):
        widget.bind("<Enter>", lambda e: widget.focus_set())
        widget.bind("<MouseWheel>", self._on_mousewheel)   # Win/Mac
        widget.bind("<Button-4>", self._on_mousewheel)     # Linux su
        widget.bind("<Button-5>", self._on_mousewheel)     # Linux giù

# ---------- Logica principale ----------
def aggiorna_listino():
    conn = None
    try:
        prefs = load_prefs()

        conn = psycopg2.connect(**db_config)
        cur = conn.cursor()
        print('Connesso al database PostgreSQL.')

        # Categorie in ordine naturale
        cur.execute('SELECT id, descrizione FROM tipologie')
        categorie_rows = cur.fetchall()
        categorie = [{'id': row[0], 'descrizione': row[1]} for row in categorie_rows]

        # Pietanze per categoria (ordine naturale DB)
        all_pietanze = []
        for cat in categorie:
            cur.execute("""
                SELECT 
                    id, 
                    descrizione, 
                    TRIM(TRAILING '.' FROM REPLACE(TRIM(TRAILING '0' FROM prezzo::text), '.', ',')) as prezzo 
                FROM articoli 
                WHERE id_tipologia = %s
            """, (cat['id'],))
            for row in cur.fetchall():
                all_pietanze.append({
                    'id': row[0],
                    'descrizione': row[1],
                    'prezzo': row[2],
                    'id_tipologia': cat['id'],
                    'tipologia_desc': cat['descrizione']
                })

        # --- GUI ---
        root = tk.Tk()
        root.title("Aggiorna Listino — Seleziona Pietanze e Ordine")
        root.minsize(900, 600)  # finestra minima più ampia

        # Barra superiore con azioni
        topbar = ttk.Frame(root)
        topbar.pack(fill="x", padx=10, pady=6)

        # (Facoltativo) field di ricerca testuale per filtrare visivamente
        ttk.Label(topbar, text="Filtra:").pack(side="left")
        filter_var = tk.StringVar()
        filter_entry = ttk.Entry(topbar, textvariable=filter_var, width=30)
        filter_entry.pack(side="left", padx=(6, 12))

        def apply_filter(*args):
            q = filter_var.get().strip().lower()
            for cat_id, rows in per_cat_widgets.items():
                for r in rows:
                    txt = f"{r['pietanza']['descrizione']} ({r['pietanza']['prezzo']})".lower()
                    visible = (q in txt) if q else True
                    # mostra/nascondi la riga
                    try:
                        if visible:
                            r['rowf'].pack(fill="x", padx=8, pady=1)
                        else:
                            r['rowf'].pack_forget()
                    except Exception:
                        pass
        filter_var.trace_add("write", apply_filter)

        # Area centrale scrollabile
        scroll = ScrollableFrame(root)
        scroll.pack(fill="both", expand=True)

        inner = scroll.inner  # dove disegnare i contenuti

        per_cat_widgets = {cat['id']: [] for cat in categorie}

        for cat in categorie:
            lf = ttk.LabelFrame(inner, text=f"[{cat['id']}] {cat['descrizione']}")
            lf.pack(fill="x", expand=True, padx=10, pady=8)

            cat_items = [p for p in all_pietanze if p['id_tipologia'] == cat['id']]
            if not cat_items:
                ttk.Label(lf, text="(Nessuna pietanza)").pack(anchor="w", padx=8, pady=2)
                continue

            header = ttk.Frame(lf)
            header.pack(fill="x", padx=8, pady=(4,2))
            ttk.Label(header, text="Includi", width=8).grid(row=0, column=0, sticky="w")
            ttk.Label(header, text="Ord.", width=6).grid(row=0, column=1, sticky="w")
            ttk.Label(header, text="Descrizione (Prezzo)").grid(row=0, column=2, sticky="w")

            next_default = 1
            for idx, p in enumerate(cat_items):
                rowf = ttk.Frame(lf)
                rowf.pack(fill="x", padx=8, pady=1)

                include_default = get_pref_include(prefs, cat['id'], p['id'])
                var_chk = tk.BooleanVar(value=include_default)
                chk = ttk.Checkbutton(rowf, variable=var_chk)
                chk.grid(row=0, column=0, sticky="w", padx=(0,6))

                saved_order = get_pref_order(prefs, cat['id'], p['id'])
                if isinstance(saved_order, int) and saved_order > 0:
                    ord_val = saved_order
                else:
                    ord_val = next_default
                    next_default += 1

                var_ord = tk.StringVar(value=str(ord_val))
                ent = ttk.Entry(rowf, textvariable=var_ord, width=6, justify="right")
                ent.grid(row=0, column=1, sticky="w", padx=(0,10))

                ttk.Label(rowf, text=f"{p['descrizione']} ({p['prezzo']})").grid(row=0, column=2, sticky="w")

                per_cat_widgets[cat['id']].append({
                    'pietanza': p,
                    'var_chk': var_chk,
                    'var_ord': var_ord,
                    'original_index': idx,
                    'rowf': rowf
                })

        # Bottoni inferiori
        bottombar = ttk.Frame(root)
        bottombar.pack(fill="x", padx=10, pady=8)

        def on_continua():
            # Salva preferenze e genera data.js
            save_prefs(per_cat_widgets)

            filtered_elenco_pietanze = {cat['descrizione']: [] for cat in categorie}

            for cat in categorie:
                rows = per_cat_widgets[cat['id']]
                ordered = []
                for r in rows:
                    p = r['pietanza']
                    if not r['var_chk'].get():
                        continue
                    try:
                        ord_val = int(r['var_ord'].get())
                    except Exception:
                        ord_val = 10_000_000
                    ordered.append((ord_val, r['original_index'], p))

                ordered.sort(key=lambda t: (t[0], t[1]))
                for _, __, p in ordered:
                    filtered_elenco_pietanze[next(c['descrizione'] for c in categorie if c['id']==p['id_tipologia'])].append({
                        'id': p['id'],
                        'descrizione': p['descrizione'],
                        'prezzo': p['prezzo']
                    })

            elenco_principale = [cat['descrizione'] for cat in categorie if filtered_elenco_pietanze[cat['descrizione']]]

            data_js_content = f"// data.js - Generato automaticamente (Data: {datetime.now().isoformat()})\n\n"
            data_js_content += f"var elencoPrincipale = {json.dumps(elenco_principale, indent=2, ensure_ascii=False)};\n"
            data_js_content += f"var categorie = {json.dumps(categorie, indent=2, ensure_ascii=False)};\n"
            data_js_content += f"var elencoPietanze = {json.dumps(filtered_elenco_pietanze, indent=2, ensure_ascii=False)};\n\n"
            data_js_content += r"""function Data(){
   var riferimentoHashMap = "_hashmap";
   var riferimentoCoperti = "_coperti";

   this.getInstanceHashmap = function(){
      function recreateHashmap(value){
         var hashmap = new HashMap();
         if (value && Array.isArray(value)) {
             for(var i = 0; i < value.length; i++){
                if (value[i] && typeof value[i].key !== 'undefined' && typeof value[i].val !== 'undefined') {
                    hashmap.put(value[i].key, value[i].val);
                }
             }
         }
         return hashmap;
      }
      var hashmapCookieValue = $.cookie(riferimentoHashMap);
      if(typeof hashmapCookieValue !== 'undefined' && hashmapCookieValue !== null && hashmapCookieValue !== ""){
         try {
             var parsedCookie = JSON.parse(hashmapCookieValue);
             if (parsedCookie && parsedCookie.value && Array.isArray(parsedCookie.value)) {
                 return recreateHashmap(parsedCookie.value);
             } else {
                 this.deleteAllData();
                 var newHashmap = new HashMap();
                 this.saveInstanceHashmap(newHashmap);
                 return newHashmap;
             }
         } catch (e) {
             this.deleteAllData();
             var newHashmap = new HashMap();
             this.saveInstanceHashmap(newHashmap);
             return newHashmap;
         }
      } else {
         var hashmap = new HashMap();
         this.saveInstanceHashmap(hashmap);
         return hashmap;
      }
   }

   this.saveInstanceHashmap = function(hashmap){
      $.cookie(riferimentoHashMap, JSON.stringify(hashmap), { expires: 7, path: '/', json: true });
   }

   this.getInstanceCoperti = function(){
      var coperti = $.cookie(riferimentoCoperti);
      if(typeof coperti !== 'undefined' && coperti !== null && coperti !== ""){
         return parseInt(coperti);
      }else{
         this.saveInstanceCoperti(0);
         return 0;
      }
   }

   this.saveInstanceCoperti = function(coperti){
      $.cookie(riferimentoCoperti, coperti, { expires: 7, path: '/', json: true });
   }

   this.deleteAllData = function(){
      $.removeCookie(riferimentoHashMap, { path: '/' });
      $.removeCookie(riferimentoCoperti, { path: '/' });
   }
}
"""
            os.makedirs(os.path.dirname(OUTPUT_DATA_JS), exist_ok=True)
            with open(OUTPUT_DATA_JS, 'w', encoding='utf-8') as f:
                f.write(data_js_content)

            messagebox.showinfo("Completato", f"data.js generato.\nPreferenze salvate in:\n{PREFS_PATH}")
            root.destroy()

        ttk.Button(bottombar, text="CONTINUA", command=on_continua).pack(side="right")

        # Suggerimenti d'uso
        hint = ttk.Label(bottombar, text="Suggerimento: usa la rotellina del mouse o il trackpad per scorrere la lista. Puoi anche filtrare in alto.")
        hint.pack(side="left")

        root.mainloop()

    except psycopg2.Error as e:
        print('ERRORE DB:', e)
        messagebox.showerror("Errore Database", f"Errore DB:\n{e}")
    except Exception as e:
        print('ERRORE:', e)
        try:
            messagebox.showerror("Errore", f"Errore:\n{e}")
        except Exception:
            pass
    finally:
        if conn:
            conn.close()
            print('Connessione al database chiusa.')

if __name__ == "__main__":
    aggiorna_listino()
